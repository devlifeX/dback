package wordpress

import (
	"archive/zip"
	"crypto/rand"
	"encoding/hex"
	"fmt"
	"os"
	"strings"
)

const pluginTemplate = `<?php

/**
 * Plugin Name: DB Sync Connector
 * Description: generated by DB Sync Manager App. Handles database export/import securely.
 * Version: 1.0.0
 * Author: DB Sync Manager
 */

if (!defined('ABSPATH')) {
  exit;
}

define('DBACK_API_KEY', '{{API_KEY}}');

class DBack_Sync_API {

  public function __construct() {
    add_action('rest_api_init', array($this, 'register_routes'));
  }

  public function register_routes() {
    register_rest_route('dback/v1', '/export', array(
      'methods' => 'GET',
      'callback' => array($this, 'handle_export'),
      'permission_callback' => array($this, 'check_permission'),
    ));

    register_rest_route('dback/v1', '/import', array(
      'methods' => 'POST',
      'callback' => array($this, 'handle_import'),
      'permission_callback' => array($this, 'check_permission'),
    ));
  }

  public function check_permission($request) {
    $auth_header = $request->get_header('X-DBACK-KEY');
    return $auth_header === DBACK_API_KEY;
  }

  public function handle_export($request) {
    // Increase limits
    set_time_limit(0);
    ini_set('memory_limit', '512M');

    global $wpdb;
    $db_name = DB_NAME;
    $db_user = DB_USER;
    $db_pass = DB_PASSWORD;
    $db_host = DB_HOST;

    // Use mysqldump via exec if available (fastest)
    $dump_file = wp_upload_dir()['basedir'] . '/dback_dump_' . time() . '.sql.gz';

    // Command: mysqldump ... | gzip > file
    // Note: We rely on system mysqldump.
    $cmd = sprintf(
      'mysqldump -h %s -u %s -p%s %s | gzip > %s',
      escapeshellarg($db_host),
      escapeshellarg($db_user),
      escapeshellarg($db_pass),
      escapeshellarg($db_name),
      escapeshellarg($dump_file)
    );

    // Execute
    exec($cmd, $output, $return_var);

    if ($return_var !== 0) {
      return new WP_Error('export_failed', 'mysqldump command failed', array('status' => 500));
    }

    if (!file_exists($dump_file)) {
      return new WP_Error('export_failed', 'Dump file not found', array('status' => 500));
    }

    // Stream file download
    $file_size = filesize($dump_file);

    // Clean buffer
    if (ob_get_level()) ob_end_clean();

    header('Content-Description: File Transfer');
    header('Content-Type: application/gzip');
    header('Content-Disposition: attachment; filename=' . basename($dump_file));
    header('Content-Length: ' . $file_size);
    header('Expires: 0');
    header('Cache-Control: must-revalidate');
    header('Pragma: public');

    readfile($dump_file);

    // Delete after send
    unlink($dump_file);
    exit;
  }

  public function handle_import($request) {
    // Logic to receive file and pipe to mysql
    // PHP REST API usually handles small bodies. For large dumps, we normally stream.
    // But WP REST API buffers body?
    // Ideally, we should read from php://input.

    set_time_limit(0);

    global $wpdb;
    $db_name = DB_NAME;
    $db_user = DB_USER;
    $db_pass = DB_PASSWORD;
    $db_host = DB_HOST;

    // We can't easily pipe php://input to mysql directly in some setups if body is parsed.
    // But let's try saving to temp file first.
    $upload_dir = wp_upload_dir()['basedir'];
    $temp_file = $upload_dir . '/dback_import_' . time() . '.sql.gz';

    $input = fopen('php://input', 'rb');
    $file = fopen($temp_file, 'wb');
    stream_copy_to_stream($input, $file);
    fclose($input);
    fclose($file);

    // Now run mysql command
    // gunzip -c file | mysql ...
    $cmd = sprintf(
      'gunzip -c %s | mysql -h %s -u %s -p%s %s',
      escapeshellarg($temp_file),
      escapeshellarg($db_host),
      escapeshellarg($db_user),
      escapeshellarg($db_pass),
      escapeshellarg($db_name)
    );

    exec($cmd, $output, $return_var);

    unlink($temp_file);

    if ($return_var !== 0) {
      return new WP_Error('import_failed', 'mysql command failed', array('status' => 500));
    }

    return rest_ensure_response(array('success' => true, 'message' => 'Database imported successfully'));
  }
}

new DBack_Sync_API();`

// GeneratePlugin creates a WP plugin zip with a unique key
func GeneratePlugin(templatePath, destDir string) (string, string, error) {
	// Generate Key
	key, err := generateKey()
	if err != nil {
		return "", "", err
	}

	// Use embedded template
	content := pluginTemplate

	// Replace Key
	pluginCode := strings.ReplaceAll(content, "{{API_KEY}}", key)

	// Create Zip
	zipPath := fmt.Sprintf("%s/dback-sync-plugin.zip", destDir)
	file, err := os.Create(zipPath)
	if err != nil {
		return "", "", err
	}
	defer file.Close()

	w := zip.NewWriter(file)
	defer w.Close()

	// Add file to zip
	f, err := w.Create("dback-sync/dback-sync.php")
	if err != nil {
		return "", "", err
	}
	_, err = f.Write([]byte(pluginCode))
	if err != nil {
		return "", "", err
	}

	return key, zipPath, nil
}

func generateKey() (string, error) {
	bytes := make([]byte, 32)
	if _, err := rand.Read(bytes); err != nil {
		return "", err
	}
	return hex.EncodeToString(bytes), nil
}
